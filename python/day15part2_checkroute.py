#!/usr/bin/python3
# Python solution for AOC 2021 Day 15, Part 2
# Given an input "Risk Map" compute the lowest-risk path from top left (0,0)
# to bottom right (maxX,maxY).
# Moves may not be made diagonally.
# Route risk is computed as the sum of the risk values entered on the path.
##
# Note that prior to use the map must be "grown" by 5 x in every dimension with
# risk scores incrementing by 1 (mod10) each time.
#
# The previous approach - calculating cost-to-finish for each point back from
# the end to the start - appears to have fluked the answer to Part 1.
# Irritatingly it also produces the "right" answer for the example data in Part 2
# but too big a value (apparently) for the live data set.
#
# NOTE PER THE HINTS ON REDDIT: Despite the sample data AND the part 1 solution
# not requiring "backtracking", there's nothing in the specification that
# precludes movement "left" or "up". If there was, my simpler part1 solution
# of back-calculating would be perfect.
#
# As a result, we need to implement the Dijkstra algorithm to find the cheapest
# cost from start to finish...
# Have tried to optimise it (a bit) but it's still slow using dicts and lists.
# This *is* a justification for using the "HiPower" profile on my machine to
# cut down calc costs.
#
# Note that the "Dijkstra Cost" shown is an analogue of the actual cost; the
# correct cost according to the specification is the "checksum" cost shown
# after display
#
# As a bonus, automatically does visualisation to a PNG

#inputfile = "data/day15test.txt"
inputfile = "data/day15part1.txt"

#Globals All The Way
map=[]
maxX=0
maxY=0
growthFactor=5

route = [499499, 498498, 497497, 496496, 496495, 495494, 494494, 493493, 493492,
 492491, 491490, 490490, 489489, 490488, 489487, 490486, 490485, 489484, 489483,
 488482, 487482, 486483, 485483, 484482, 483481, 482480, 482479, 481478, 481477,
 481476, 480475, 479474, 478473, 477472, 476471, 475470, 474469, 474468, 474467,
 473466, 472467, 471467, 470466, 469467, 468466, 467465, 466464, 466463, 465462,
 464461, 465460, 464459, 463458, 462457, 463456, 463455, 463454, 462453, 461452,
 460452, 459452, 458451, 457451, 456450, 455449, 454448, 455447, 454446, 453446,
 452445, 451444, 450443, 449443, 448442, 447442, 446443, 445443, 444442, 443443,
 442442, 441441, 440442, 439442, 438442, 437442, 436442, 435441, 435440, 434439,
 433438, 432437, 431436, 430435, 429435, 428434, 427433, 426433, 425432, 425431,
 424430, 423430, 422431, 421430, 420429, 419428, 418427, 417426, 417425, 417424,
 416423, 417422, 416421, 415420, 414419, 413419, 412418, 411417, 410417, 409416,
 408416, 407417, 406416, 405415, 404414, 403413, 402412, 401411, 401410, 402409,
 402408, 401407, 400407, 399406, 400405, 399404, 398403, 399402, 398401, 397400,
 396399, 396398, 395397, 394397, 393396, 392395, 391395, 390394, 390393, 389392,
 388391, 387390, 386389, 385388, 384387, 384386, 383385, 382384, 381384, 380384,
 379385, 378386, 377387, 376386, 375385, 374385, 373386, 372385, 371384, 370384,
 369384, 368383, 367382, 367381, 366380, 365379, 364378, 363377, 362376, 361376,
 360376, 359375, 358376, 357377, 356376, 355375, 354375, 353374, 352373, 351374,
 350373, 349372, 348373, 347372, 347371, 346370, 345370, 344371, 343372, 342372,
 341372, 340371, 339372, 338371, 337370, 336369, 335370, 334369, 333368, 334367,
 334366, 335365, 335364, 334363, 333362, 332361, 331360, 330359, 329358, 329357,
 328356, 327356, 326355, 325355, 324356, 323356, 322355, 321354, 322353, 321352,
 321351, 320350, 319349, 318349, 317348, 316347, 315346, 315345, 314344, 313343,
 312342, 311341, 310340, 310339, 309338, 308337, 307337, 306336, 306335, 306334,
 305333, 304332, 304331, 305330, 304329, 304328, 304327, 303326, 302325, 301324,
 300323, 299322, 298321, 297321, 296320, 296319, 295318, 294317, 293316, 292315,
 291314, 290313, 289312, 288312, 287311, 286310, 285310, 284309, 283308, 282307,
 282306, 281305, 280304, 279303, 278303, 277302, 276301, 275300, 275299, 274298,
 274297, 275296, 274295, 274294, 275293, 275292, 275291, 274290, 273289, 272288,
 271287, 270286, 269287, 268286, 267285, 266284, 265283, 266282, 265281, 266280,
 266279, 265278, 264277, 263276, 262275, 261274, 260273, 259272, 258271, 257272,
 256271, 255271, 254270, 253269, 252269, 251268, 250268, 249267, 248267, 247268,
 246268, 245267, 244266, 243266, 242265, 241264, 240264, 239263, 238263, 237263,
 236264, 235263, 234263, 233264, 232263, 231263, 230262, 230261, 229260, 228259,
 228258, 227257, 226256, 225255, 224256, 223255, 222254, 221253, 220252, 219251,
 218250, 217250, 216250, 215249, 214248, 213248, 212247, 211246, 210246, 209245,
 208245, 207244, 207243, 206242, 205241, 204241, 203242, 202241, 201240, 200241,
 199241, 198240, 197239, 196238, 195238, 194237, 193236, 192235, 191234, 190233,
 189232, 188232, 187232, 186231, 185230, 184229, 183230, 182229, 181228, 180227,
 179228, 178228, 177228, 176227, 175226, 175225, 174224, 173224, 172223, 171222,
 170222, 169222, 168221, 167220, 166220, 165219, 164218, 163218, 162217, 161216,
 160215, 159214, 158213, 157212, 156212, 155211, 155210, 155209, 154208, 153207,
 154206, 155205, 155204, 154203, 155202, 155201, 155200, 155199, 154198, 153197,
 153196, 152195, 152194, 151193, 150192, 149192, 148191, 148190, 147189, 147188,
 146187, 145188, 144187, 143186, 142187, 141186, 140185, 139186, 138185, 137185,
 136184, 135184, 134183, 133182, 132181, 131180, 130179, 129178, 128177, 127178,
 126179, 125179, 124180, 123179, 122178, 122177, 121176, 120175, 119174, 118173,
 117173, 116172, 117171, 116170, 115169, 114169, 113168, 112167, 111167, 110166,
 109165, 108164, 107164, 106163, 105163, 104162, 103161, 102161, 101161, 100160,
 99159, 98158, 97157, 96156, 95156, 94156, 93155, 92155, 91154, 90153, 89153, 88152,
 87151, 86150, 87149, 88148, 87147, 86146, 87145, 86144, 85143, 85142, 86141, 85140,
 85139, 84138, 83137, 82136, 81135, 80134, 79133, 78132, 77133, 76132, 75131, 74132,
 73131, 72130, 71129, 70128, 69127, 69126, 68125, 67125, 66124, 65123, 64123, 63122,
 62121, 61121, 60120, 59121, 58121, 57120, 56119, 55119, 54118, 53117, 52116, 51116,
 50115, 49114, 48113, 48112, 48111, 47110, 46109, 45108, 44107, 43107, 42108, 41109,
 40110, 39109, 39108, 40107, 39106, 38105, 37104, 37103, 36102, 35102, 34101, 33100,
 32099, 31098, 31097, 30096, 29096, 28095, 28094, 29093, 28092, 28091, 28090, 28089,
 28088, 29087, 29086, 28085, 28084, 27083, 27082, 26081, 25080, 24079, 24078, 23077,
 22076, 21075, 21074, 20073, 19073, 18072, 18071, 18070, 17069, 16068, 15067, 14066,
 13065, 12064, 12063, 13062, 12061, 12060, 12059, 12058, 12057, 12056, 13055, 13054,
 12053, 11052, 11051, 10050, 9050, 8049, 9048, 10048, 11047, 11046, 12045, 12044,
 13043, 14042, 14041, 15040, 16039, 17038, 18037, 18036, 18035, 19034, 20033, 20032,
 20031, 19030, 18029, 17028, 16027, 16026, 15025, 14024, 14023, 13022, 12023, 11022,
 10021, 10020, 9019, 8018, 7017, 6016, 5017, 4016, 3015, 2014, 1013, 2012, 3011,
 3010, 2009, 2008, 2007, 3006, 4005, 3004, 2003, 2002, 1001, 0]


#-----------------------------------------------------------------------
def loadMap(file) :
    map=[]
    with open(file,'r') as maplines :
        for l in maplines:
            c=l.strip()
            if len(c)>0 :
                map.append(c)
    return map
#-----------------------------------------------------------------------
def growMap(srcmap) :
    global map
    orgX=len(srcmap[0])
    orgY=len(srcmap)
    #Re-initialise the global map
    map = ["" for y in range(orgY*growthFactor)]
    print(f"map now has {len(map)} rows (source had {len(srcmap)})")
    for y in range(len(map)) :
        srcY=y%orgY
        dY=y//orgY
        line=""
        for x in range(orgX*growthFactor) :
            srcX=x%orgX
            dX=x//orgX
            srcP=int(srcmap[srcY][srcX])
            newP=srcP + dX + dY
            if newP>9 :
                newP=newP-9
            line += str(newP)
            #print(f"{line} {srcP}->(+{dX+dY})->{newP}")
        if len(line)!=orgY*growthFactor :
            print(f"Cock-up producing line {y} : {line}")
            exit()
        map[y]=line

#-----------------------------------------------------------------------
def cKey(x,y) :
    return x*1000 + y
    #return str(x) + "," + str(y)
#-----------------------------------------------------------------------
def fast_cKey(k) :
    return k[0]*1000 + k[1]
    #return str(x) + "," + str(y)
#-----------------------------------------------------------------------
def uKey(k) :
    if k==0 :
        return([0,0])
    elif k<1000 :
        return([0,k])
    else :
        y=k%1000
        x=(k-y)//1000
        return([x,y])
#-----------------------------------------------------------------------
def check_route(path) :
    cost=0
    for p in path :
        c = uKey(p)
        if c[0]==0 and c[1]==0 :
            print(f"Arrived at Source. Total cost: {cost}")
        else :
            cost += int(map[c[1]][c[0]])
    return cost
#-----------------------------------------------------------------------
def plotPath(path,pngfile) :
    RESET = "\033[0;0m"
    BOLD    = "\033[;1m"
    RED   = "\033[1;31m"
    YELLOW = '\033[33m'
    REVERSE = "\033[;7m"
    #import sys
    checkSum=0

    for y in range(maxY+1) :
        for x in range(maxX+1) :
            if cKey(x,y) in path :
                checkSum+=int(map[y][x])
                if maxY<101 :
                    print(REVERSE + YELLOW + map[y][x] + RESET,end="")
            elif maxY<101 :
                print(map[y][x],end="")
        if maxY<101 :
            print()
    checkSum -= int(map[0][0])
    print(f"Shown path checksum: {checkSum}")

    import png
    img=[]
    colourLUT={'9' : [0,25,51],
               '8' : [0,51,102],
               '7' : [0,76,153],
               '6' : [0,102,204],
               '5' : [0,128,255],
               '4' : [51,153,255],
               '3' : [102,178,255],
               '2' : [153,204,255],
               '1' : [204,229,255] }
    scale=2
    height=len(map) * scale
    width=len(map[0]) * scale
    for y in range(height) :
        for x in range(width) :
            sX=x//scale
            sY=y//scale
            if cKey(sX,sY) in path :
                img.extend([255,255,0])
            else :
                img.extend(colourLUT[map[sY][sX]])

    print(f"writing image {pngfile}")
    with open(pngfile, 'wb') as f:
        w = png.Writer(width, height, greyscale=False, alpha=False)
        w.write_array(f,img)

#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
#-----------------------------------------------------------------------
if __name__ == "__main__" :
    map=loadMap(inputfile)
    growMap(map)
    maxX=len(map[0])-1
    maxY=len(map[1])-1
    print(f"map is of size {maxX+1} x {maxY+1}")
    rCost = check_route(route)
